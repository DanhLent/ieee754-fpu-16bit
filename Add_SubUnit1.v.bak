module Add_SubUnit1(
    input wire CLK,
    input wire Reset,
    input wire Start,
    input wire Select,   // 0: Add, 1: Sub
    input wire [15:0] Ain,
    input wire [15:0] Bin,
    output wire Done,
    output wire [15:0] Out
);

    // ============================================================
    // KHAI BÁO DÂY TÍN HIỆU NỐI CÁC TẦNG (WIRES)
    // ============================================================
    
    // --- Signals for Input Parsing ---
    wire sign_a, sign_b;
    wire [4:0] exp_a, exp_b;
    wire [10:0] man_a, man_b;
    wire a_gt_b;
    
    // --- Signals for Stage 1 Logic ---
    wire [4:0] exp_diff;
    wire [4:0] s1_mux_exp;
    wire s1_mux_sign;
    wire [11:0] s1_mux_man_l;
    wire [11:0] s1_man_s_in;
    wire [11:0] s1_man_s_shifted_wire;
    wire actual_sub;
    
    // --- Register Outputs of Stage 1 (Inputs to Stage 2) ---
    wire s1_start_reg;
    wire [4:0] s1_exp_max_reg;
    wire s1_sign_l_reg;
    wire s1_real_op_reg;
    wire [11:0] s1_man_l_reg;
    wire [11:0] s1_man_s_shifted_reg;

    // --- Signals for Stage 2 Logic ---
    wire [12:0] s2_sum_wire;
    
    // --- Register Outputs of Stage 2 (Inputs to Stage 3) ---
    wire s2_start_reg;
    wire [4:0] s2_exp_max_reg;
    wire s2_sign_l_reg;
    wire s2_real_op_reg; // Lưu ý: Biến này trong code gốc được truyền nhưng không dùng tính toán ở stage 3, chỉ để pipeline
    wire [12:0] s2_sum_reg;

    // --- Signals for Stage 3 Logic ---
    wire [3:0] l_zeros;
    wire [4:0] final_exp_norm;
    wire [11:0] shifted_man;
    wire [9:0] final_man_norm;
    wire [15:0] result_mux_out;
    wire is_overflow, is_underflow, is_zero;
    wire [15:0] res_overflow, res_norm;

    // ============================================================
    // STAGE 1: DECODE & ALIGNMENT
    // ============================================================

    // 1. Tách các thành phần của A và B
    assign sign_a = Ain[15];
    assign sign_b = Bin[15];
    assign exp_a  = Ain[14:10];
    assign exp_b  = Bin[14:10];

    // 2. Thêm bit ẩn (Hidden bit logic)
    // Dùng Mux 2 kênh để chọn có thêm bit 1 hay bit 0 vào đầu mantissa
    assign man_a = (exp_a == 5'd0) ? {1'b0, Ain[9:0]} : {1'b1, Ain[9:0]};
    assign man_b = (exp_b == 5'd0) ? {1'b0, Bin[9:0]} : {1'b1, Bin[9:0]};

    // 3. So sánh A và B (Logic xác định số lớn hơn)
    // a_gt_b = (exp_a > exp_b) || (exp_a == exp_b && man_a > man_b);
    CMP_Magnitude cmp_inst (
        .exp_a(exp_a), .exp_b(exp_b),
        .man_a(man_a), .man_b(man_b),
        .a_gt_b(a_gt_b)
    );

    // 4. Tính chênh lệch mũ (Exp Diff)
    // exp_diff = a_gt_b ? (exp_a - exp_b) : (exp_b - exp_a);
    SUB_5bit sub_exp (
        .in1(a_gt_b ? exp_a : exp_b),
        .in2(a_gt_b ? exp_b : exp_a),
        .out(exp_diff)
    );

    // 5. Xác định dấu phép tính thực (Actual Sub)
    assign actual_sub = sign_a ^ sign_b ^ Select;

    // 6. Các bộ MUX chọn tín hiệu cho số Lớn/Bé trước khi vào thanh ghi pipeline
    assign s1_mux_exp   = a_gt_b ? exp_a : exp_b;
    assign s1_mux_sign  = a_gt_b ? sign_a : (Select ? ~sign_b : sign_b);
    assign s1_mux_man_l = a_gt_b ? {man_a, 1'b0} : {man_b, 1'b0};
    assign s1_man_s_in  = a_gt_b ? {man_b, 1'b0} : {man_a, 1'b0};

    // 7. Dịch phải Mantissa số bé (Barrel Shifter Right)
    Shifter_Right_Barrel shift_r_inst (
        .in_data(s1_man_s_in),
        .shift_amt(exp_diff),
        .out_data(s1_man_s_shifted_wire)
    );

    // 8. PIPELINE REGISTERS (STAGE 1 -> STAGE 2)
    REG_1bit  reg_s1_start (.clk(CLK), .rst(Reset), .in(Start),                 .out(s1_start_reg));
    REG_5bit  reg_s1_exp   (.clk(CLK), .rst(Reset), .in(s1_mux_exp),            .out(s1_exp_max_reg));
    REG_1bit  reg_s1_sign  (.clk(CLK), .rst(Reset), .in(s1_mux_sign),           .out(s1_sign_l_reg));
    REG_1bit  reg_s1_op    (.clk(CLK), .rst(Reset), .in(actual_sub),            .out(s1_real_op_reg));
    REG_12bit reg_s1_manl  (.clk(CLK), .rst(Reset), .in(s1_mux_man_l),          .out(s1_man_l_reg));
    REG_12bit reg_s1_mans  (.clk(CLK), .rst(Reset), .in(s1_man_s_shifted_wire), .out(s1_man_s_shifted_reg));


    // ============================================================
    // STAGE 2: ARITHMETIC (ADD/SUB)
    // ============================================================

    // 1. Thực hiện cộng hoặc trừ Mantissa
    ADD_SUB_13bit alu_inst (
        .a({1'b0, s1_man_l_reg}),
        .b({1'b0, s1_man_s_shifted_reg}),
        .sub_mode(s1_real_op_reg),
        .res(s2_sum_wire)
    );

    // 2. PIPELINE REGISTERS (STAGE 2 -> STAGE 3)
    REG_1bit  reg_s2_start (.clk(CLK), .rst(Reset), .in(s1_start_reg),   .out(s2_start_reg));
    REG_5bit  reg_s2_exp   (.clk(CLK), .rst(Reset), .in(s1_exp_max_reg), .out(s2_exp_max_reg));
    REG_1bit  reg_s2_sign  (.clk(CLK), .rst(Reset), .in(s1_sign_l_reg),  .out(s2_sign_l_reg));
    REG_1bit  reg_s2_op    (.clk(CLK), .rst(Reset), .in(s1_real_op_reg), .out(s2_real_op_reg));
    REG_13bit reg_s2_sum   (.clk(CLK), .rst(Reset), .in(s2_sum_wire),    .out(s2_sum_reg));


    // ============================================================
    // STAGE 3: NORMALIZATION & PACKING
    // ============================================================

    // 1. Tìm số lượng bit 0 đầu tiên (Leading Zero Detector)
    LZD_13bit lzd_inst (
        .in(s2_sum_reg),
        .out(l_zeros)
    );

    // 2. Tính Exponent sau chuẩn hóa
    // final_exp_norm = s2_exp_max_reg - l_zeros;
    assign final_exp_norm = s2_exp_max_reg - {1'b0, l_zeros}; // Simple subtract structure

    // 3. Dịch trái Mantissa để chuẩn hóa (Barrel Shifter Left)
    // shifted_man = s2_sum[11:0] << l_zeros;
    Shifter_Left_Barrel shift_l_inst (
        .in_data(s2_sum_reg[11:0]),
        .shift_amt(l_zeros),
        .out_data(shifted_man)
    );
    
    assign final_man_norm = shifted_man[10:1]; // Bỏ bit ẩn

    // 4. Logic chọn kết quả đầu ra (Zero, Overflow, Underflow, Normal)
    assign is_zero      = (s2_sum_reg == 13'd0);
    assign is_overflow  = s2_sum_reg[12];
    assign is_underflow = (s2_exp_max_reg < {1'b0, l_zeros});

    // Tạo các giá trị ứng viên
    assign res_overflow = {s2_sign_l_reg, (s2_exp_max_reg + 5'd1), s2_sum_reg[11:2]};
    assign res_norm     = {s2_sign_l_reg, final_exp_norm, final_man_norm};

    // MUX chọn kết quả cuối cùng (Priority Mux structure logic)
    assign result_mux_out = is_zero      ? 16'h0000 :
                            is_overflow  ? res_overflow :
                            is_underflow ? 16'h0000 :
                            res_norm;

    // 5. PIPELINE REGISTERS (OUTPUT)
    REG_1bit  reg_out_done (.clk(CLK), .rst(Reset), .in(s2_start_reg),   .out(Done));
    REG_16bit reg_out_data (.clk(CLK), .rst(Reset), .in(result_mux_out), .out(Out));

endmodule


// ============================================================================
// CÁC MODULE CON HỖ TRỢ (HELPER MODULES)
// Để đảm bảo tính chất "Structural", ta định nghĩa các khối chức năng rời rạc.
// ============================================================================

// --- 1. Registers ---
module REG_1bit (input clk, rst, in, output reg out);
    always @(posedge clk or posedge rst) begin
        if (rst) out <= 1'b0; else out <= in;
    end
endmodule

module REG_5bit (input clk, rst, input [4:0] in, output reg [4:0] out);
    always @(posedge clk or posedge rst) begin
        if (rst) out <= 5'd0; else out <= in;
    end
endmodule

module REG_12bit (input clk, rst, input [11:0] in, output reg [11:0] out);
    always @(posedge clk or posedge rst) begin
        if (rst) out <= 12'd0; else out <= in;
    end
endmodule

module REG_13bit (input clk, rst, input [12:0] in, output reg [12:0] out);
    always @(posedge clk or posedge rst) begin
        if (rst) out <= 13'd0; else out <= in;
    end
endmodule

module REG_16bit (input clk, rst, input [15:0] in, output reg [15:0] out);
    always @(posedge clk or posedge rst) begin
        if (rst) out <= 16'd0; else out <= in;
    end
endmodule

// --- 2. Comparators ---
module CMP_Magnitude(
    input [4:0] exp_a, exp_b,
    input [10:0] man_a, man_b,
    output a_gt_b
);
    assign a_gt_b = (exp_a > exp_b) || (exp_a == exp_b && man_a > man_b);
endmodule

// --- 3. Arithmetic ---
module SUB_5bit(input [4:0] in1, in2, output [4:0] out);
    assign out = in1 - in2;
endmodule

module ADD_SUB_13bit(input [12:0] a, b, input sub_mode, output [12:0] res);
    assign res = sub_mode ? (a - b) : (a + b);
endmodule

// --- 4. Shifters ---
module Shifter_Right_Barrel(input [11:0] in_data, input [4:0] shift_amt, output [11:0] out_data);
    assign out_data = in_data >> shift_amt;
endmodule

module Shifter_Left_Barrel(input [11:0] in_data, input [3:0] shift_amt, output [11:0] out_data);
    assign out_data = in_data << shift_amt;
endmodule

// --- 5. Leading Zero Detector (Priority Encoder) ---
module LZD_13bit(input [12:0] in, output reg [3:0] out);
    always @(*) begin
        if      (in[12]) out = 4'd0;
        else if (in[11]) out = 4'd0;
        else if (in[10]) out = 4'd1;
        else if (in[9])  out = 4'd2;
        else if (in[8])  out = 4'd3;
        else if (in[7])  out = 4'd4;
        else if (in[6])  out = 4'd5;
        else if (in[5])  out = 4'd6;
        else if (in[4])  out = 4'd7;
        else if (in[3])  out = 4'd8;
        else if (in[2])  out = 4'd9;
        else if (in[1])  out = 4'd10;
        else if (in[0])  out = 4'd11;
        else             out = 4'd12;
    end
endmodule